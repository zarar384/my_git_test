Конкурентность - это выполнение нескольких действий одновременно либо так, как будто они выполняются одновременно. Она нужна, когда приложение должно заниматься одной задачей, не прекращая работу над другой, например реагировать на ввод пользователя во время записи данных или обрабатывать несколько запросов на сервере. Практически любое приложение выигрывает от конкурентности.

Способы конкурентности:
* Многопоточность - форма конкурентности, при которой используются несколько потоков выполнения. Это лишь один из способов реализации конкурентности. Прямое использование Thread и BackgroundWorker считается устаревшим; современные приложения используют более высокоуровневые абстракции. При этом многопоточность активно используется внутри пулов потоков, которые автоматически управляют количеством потоков в зависимости от нагрузки.

* Параллельная обработка - частный случай многопоточности, при котором большой объём работы распределяется между несколькими потоками, выполняемыми одновременно, с целью эффективного использования многоядерных процессоров.

* Асинхронное программирование - форма конкурентности, позволяющая выполнять операции без блокировки потока с использованием обещаний (future/promise) или обратных вызовов. В .NET такими обещаниями являются Task и Task<TResult>. Асинхронная операция выполняется в фоне, а поток, который её запустил, может продолжать другую работу. Благодаря async и await асинхронное программирование стало почти таким же простым, как синхронное.

* Реактивное программирование - декларативный стиль, при котором приложение реагирует на поток событий. В отличие от асинхронного программирования, ориентированного на операции, здесь основой являются асинхронные события, которые могут происходить в любое время и многократно. Реактивное программирование не обязательно конкурентно, но тесно связано с конкурентностью.

Приколдесы в асинхронном программировании:
- ConfigureAwait(false) отключает возврат в исходный контекст и используется в библиотечном коде для предотвращения блокировок и повышения эффективности.
- Исключения в async-методах попадают в Task и выбрасываются в точке await, при этом сохраняется нормальная трассировка стека.
- Async-код нельзя ожидать синхронно через Wait или Result, так как это может привести к deadlock. Async должен распространяться вверх по стеку вызовов, и async-методы нужно await-ить.

Приколдесы в параллельном программировании:
- Параллельное программирование имеет смысл только для CPU-bound задач, которые можно разбить на независимые части.
- На сервере параллелизм часто бесполезен или вреден, так как сервер уже обрабатывает запросы параллельно.
- Параллелизм данных (Parallel.For / ForEach) используется для обработки независимых элементов данных.
- Параллелизм задач используется для независимых единиц работы и может быть динамическим (задачи порождают задачи).
- Чем меньше общего состояния между параллельными блоками, тем выше эффективность и проще код.
- Общие данные требуют синхронизации, а синхронизация убивает параллелизм.
- Parallel эффективнее и «вежливее» к системе, чем PLINQ; PLINQ проще, но агрессивнее по использованию CPU.
- Ошибки из параллельных операций объединяются в AggregateException и должны обрабатываться явно.
- Задачи не должны быть слишком короткими (накладные расходы) и не слишком длинными (плохой баланс нагрузки).
- Лучше использовать высокоуровневые API (Parallel, PLINQ), чем управлять Task вручную.

Агрегация - это приём параллельного программирования, при котором каждая задача работает со своей частью данных, а общий результат собирается без конкурентной записи в общее состояние.
List небезопасен при параллельной записи из-за общего счётчика, тогда как массив безопасен при записи в разные индексы.
!!! т.е List ломается из-за общего изменяемого состояния, массив работает из-за независимых ячеек, а агрегация - это способ вообще не создавать гонку.

Приколдесы в реактивном программировании (Rx):
- Реактивное программирование рассматривает поток событий как поток данных (push-модель), в отличие от LINQ, который работает по pull-модели.
- Основа Rx - наблюдаемые потоки (IObservable), которые отправляют данные подписчикам через OnNext, завершаются через OnCompleted или ошибкой через OnError.
- Rx - это по сути «LINQ для событий»: используются знакомые операторы Where, Select, Aggregate, но данные приходят сами.
- Определение наблюдаемого потока не зависит от подписки; подписка лишь начинает получение данных.
- Subscribe возвращает IDisposable, и подписку обязательно нужно освобождать, когда поток больше не нужен.
- Существуют горячие (hot) и холодные (cold) наблюдаемые потоки: горячие теряют события без подписчиков, холодные начинают работу только при подписке.
- Обработка ошибок в Subscribe обязательна, иначе ошибки могут быть потеряны.
- Subject позволяет вручную пушить события, но подходит в основном для экспериментов, а не для продакшена.
- Rx мощный, но сложный: без глубокого понимания код трудно сопровождать.

Rx - это LINQ для событий, которые приходят сами, а не по запросу.
- LINQ(pull): «дай следующий элемент» - для уже существующих данных
- Rx(push): «сообщи, когда будет клик мыши» - для данных, которые приходят со временем

Приколдесы в TPL(Task Parallel Library) Dataflow:
- TPL Dataflow предназначен для построения асинхронных и параллельных конвейеров обработки данных (pipeline).
- Основная идея: данные заходят с одного конца, проходят через цепочку блоков и выходят с другого конца автоматически.
- Базовый элемент - dataflow block: блок может принимать данные, обрабатывать их и/или передавать дальше.
- Блоки работают полунезависимо и обрабатывают данные по мере поступления, используя внутренние буферы.
- Буферизация позволяет не блокировать поток данных, но при ветвлении может привести к перекосу доставки, если не ограничивать размеры буферов.
- Ошибки внутри блока не ломают всю сеть автоматически; для типичного поведения нужно явно включать PropagateCompletion.
- Исключения в Dataflow распространяются как AggregateException и часто требуют Flatten.
- Dataflow больше подходит для параллельной обработки, чем Rx; Rx лучше подходит для работы со временем и событиями.
- Каждый блок может быть настроен на параллельную обработку (MaxDegreeOfParallelism).
- TPL Dataflow концептуально похож на акторную модель, но не является полноценным акторским фреймворком.
- Самые используемые блоки: TransformBlock (Select), TransformManyBlock (SelectMany), ActionBlock (terminal action).

Приколдесы в многопоточном программировании:
- Поток - это независимый исполнитель с собственным стеком, но общей памятью процесса.
- В приложении может существовать специальный поток (UI-поток, главный поток).
- В .NET есть пул потоков, который автоматически управляет количеством рабочих потоков.
- Пул потоков оптимизирован под реальные сценарии, его настройки почти никогда не нужно трогать.
- Создание потоков вручную через Thread практически не требуется и считается низкоуровневым подходом.
- Thread может понадобиться только в редких случаях, например для STA-потоков при COM-взаимодействии.
- Пул потоков - более высокий уровень абстракции, чем Thread, но всё ещё низкий по сравнению с Task, Parallel и Dataflow.
- Современные абстракции (Task, Parallel, Dataflow) сами используют пул потоков и скрывают детали многопоточности.
- Код на высокоуровневых абстракциях проще, безопаснее и предпочтительнее.
- Thread и BackgroundWorker считаются устаревшими и не рекомендуются к использованию.
